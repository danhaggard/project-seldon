-- 1. Update Enums for new Statuses and Types
ALTER TYPE "public"."prediction_status" ADD VALUE IF NOT EXISTS 'in_evaluation';
ALTER TYPE "public"."prediction_status" ADD VALUE IF NOT EXISTS 'vague';

CREATE TYPE "public"."source_type" AS ENUM ('primary', 'secondary');
CREATE TYPE "public"."source_status" AS ENUM ('live', 'dead', 'archived');
CREATE TYPE "public"."media_type" AS ENUM ('text', 'video', 'audio', 'social');


-- 2. Create Categories Table (Lookup Table)
CREATE TABLE "public"."categories" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" text NOT NULL,
    "slug" text NOT NULL UNIQUE,
    "description" text,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL
);

-- Enable RLS for Categories
ALTER TABLE "public"."categories" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Categories are viewable by everyone" ON "public"."categories" FOR SELECT USING (true);


-- 3. Update Predictions Table (The Big Refactor)
-- We drop old columns and add the new architecture
ALTER TABLE "public"."predictions"
    DROP COLUMN "category",          -- Replaced by category_id
    DROP COLUMN "source_url",        -- Replaced by sources table
    DROP COLUMN "resolution_date",   -- Replaced by windows
    ADD COLUMN "category_id" bigint REFERENCES "public"."categories"("id") ON DELETE SET NULL,
    ADD COLUMN "resolution_window_start" timestamp with time zone,
    ADD COLUMN "resolution_window_end" timestamp with time zone, -- Will be enforced NOT NULL in seed/app
    ADD COLUMN "resolved_at" timestamp with time zone,
    ADD COLUMN "resolved_by" uuid REFERENCES "auth"."users"("id"),
    ADD COLUMN "resolution_mechanism" text CHECK (resolution_mechanism IN ('community', 'moderator', 'automatic')),
    ADD COLUMN "quality_score" numeric(5,2) DEFAULT 50 CHECK (quality_score >= 0 AND quality_score <= 100),
    ADD COLUMN "community_vote_true_count" integer DEFAULT 0,
    ADD COLUMN "community_vote_false_count" integer DEFAULT 0;


-- 4. Create Sources Table
CREATE TABLE "public"."prediction_sources" (
    "id" uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    "prediction_id" uuid REFERENCES "public"."predictions"("id") ON DELETE CASCADE NOT NULL,
    "url" text NOT NULL,
    "type" "public"."source_type" DEFAULT 'secondary' NOT NULL,
    "status" "public"."source_status" DEFAULT 'live' NOT NULL,
    "media_type" "public"."media_type" DEFAULT 'text' NOT NULL,
    "manual_archive_url" text,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "created_by" uuid REFERENCES "auth"."users"("id") DEFAULT auth.uid()
);

-- Enable RLS for Sources
ALTER TABLE "public"."prediction_sources" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Sources are viewable by everyone" ON "public"."prediction_sources" FOR SELECT USING (true);
CREATE POLICY "Authenticated users can add sources" ON "public"."prediction_sources" FOR INSERT WITH CHECK (auth.role() = 'authenticated');


-- 5. Create Votes Table (The Ledger)
CREATE TABLE "public"."prediction_votes" (
    "id" uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    "prediction_id" uuid REFERENCES "public"."predictions"("id") ON DELETE CASCADE NOT NULL,
    "user_id" uuid REFERENCES "auth"."users"("id") ON DELETE CASCADE DEFAULT auth.uid() NOT NULL,
    "vote_outcome" boolean NOT NULL, -- True = Yes/Correct, False = No/Incorrect
    "confidence" integer CHECK (confidence >= 0 AND confidence <= 100) DEFAULT 100,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE("prediction_id", "user_id") -- Constraint: One vote per user per prediction
);

-- Enable RLS for Votes
ALTER TABLE "public"."prediction_votes" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Votes are viewable by everyone" ON "public"."prediction_votes" FOR SELECT USING (true);
CREATE POLICY "Users can vote once" ON "public"."prediction_votes" FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can change their vote" ON "public"."prediction_votes" FOR UPDATE USING (auth.uid() = user_id);


-- 6. Create Quality Ratings Table (The Meta-Review)
CREATE TABLE "public"."prediction_quality_ratings" (
    "id" uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    "prediction_id" uuid REFERENCES "public"."predictions"("id") ON DELETE CASCADE NOT NULL,
    "user_id" uuid REFERENCES "auth"."users"("id") ON DELETE CASCADE DEFAULT auth.uid() NOT NULL,
    "is_clear" boolean,
    "is_verifiable" boolean,
    "notes" text,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE("prediction_id", "user_id")
);

-- Enable RLS for Quality Ratings
ALTER TABLE "public"."prediction_quality_ratings" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Ratings viewable by everyone" ON "public"."prediction_quality_ratings" FOR SELECT USING (true);
CREATE POLICY "Users can rate quality" ON "public"."prediction_quality_ratings" FOR INSERT WITH CHECK (auth.uid() = user_id);


-- 7. Create Comments Table (Threaded)
CREATE TABLE "public"."prediction_comments" (
    "id" uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    "prediction_id" uuid REFERENCES "public"."predictions"("id") ON DELETE CASCADE NOT NULL,
    "user_id" uuid REFERENCES "auth"."users"("id") ON DELETE CASCADE DEFAULT auth.uid() NOT NULL,
    "parent_id" uuid REFERENCES "public"."prediction_comments"("id") ON DELETE CASCADE, -- Self-reference for nesting
    "content" text NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL
);

-- Enable RLS for Comments
ALTER TABLE "public"."prediction_comments" ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Comments viewable by everyone" ON "public"."prediction_comments" FOR SELECT USING (true);
CREATE POLICY "Users can comment" ON "public"."prediction_comments" FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can edit own comments" ON "public"."prediction_comments" FOR UPDATE USING (auth.uid() = user_id);


-- 8. SENIOR FEATURE: Auto-Update Vote Counts
-- This trigger keeps the 'predictions' table stats in sync whenever a vote is cast.

CREATE OR REPLACE FUNCTION update_prediction_vote_counts()
RETURNS TRIGGER AS $$
BEGIN
    -- If deleting or updating, subtract the old vote
    IF (TG_OP = 'DELETE' OR TG_OP = 'UPDATE') THEN
        IF OLD.vote_outcome = TRUE THEN
            UPDATE public.predictions SET community_vote_true_count = community_vote_true_count - 1 WHERE id = OLD.prediction_id;
        ELSE
            UPDATE public.predictions SET community_vote_false_count = community_vote_false_count - 1 WHERE id = OLD.prediction_id;
        END IF;
    END IF;

    -- If inserting or updating, add the new vote
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        IF NEW.vote_outcome = TRUE THEN
            UPDATE public.predictions SET community_vote_true_count = community_vote_true_count + 1 WHERE id = NEW.prediction_id;
        ELSE
            UPDATE public.predictions SET community_vote_false_count = community_vote_false_count + 1 WHERE id = NEW.prediction_id;
        END IF;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_prediction_vote_change
AFTER INSERT OR UPDATE OR DELETE ON public.prediction_votes
FOR EACH ROW EXECUTE FUNCTION update_prediction_vote_counts();

-- ... (Previous content of the file) ...

-- 9. SENIOR FEATURE: Guru Stats Automation
-- This ensures credibility_score is always mathematically correct based on the data.

-- A. Create the Trigger Function to count predictions
CREATE OR REPLACE FUNCTION update_guru_stats()
RETURNS TRIGGER AS $$
BEGIN
  -- Handle INSERT (New Prediction)
  IF (TG_OP = 'INSERT') THEN
    UPDATE public.gurus
    SET 
      total_predictions = total_predictions + 1,
      correct_prediction_count = CASE 
        WHEN NEW.status = 'correct' THEN correct_prediction_count + 1 
        ELSE correct_prediction_count 
      END
    WHERE id = NEW.guru_id;
  END IF;

  -- Handle DELETE (Removed Prediction)
  IF (TG_OP = 'DELETE') THEN
    UPDATE public.gurus
    SET 
      total_predictions = GREATEST(0, total_predictions - 1),
      correct_prediction_count = CASE 
        WHEN OLD.status = 'correct' THEN GREATEST(0, correct_prediction_count - 1) 
        ELSE correct_prediction_count 
      END
    WHERE id = OLD.guru_id;
  END IF;

  -- Handle UPDATE (Status Change)
  IF (TG_OP = 'UPDATE') THEN
    IF OLD.status IS DISTINCT FROM NEW.status THEN
        UPDATE public.gurus
        SET correct_prediction_count = correct_prediction_count + 
          CASE 
            WHEN NEW.status = 'correct' THEN 1 
            WHEN OLD.status = 'correct' THEN -1 
            ELSE 0 
          END
        WHERE id = NEW.guru_id;
    END IF;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- B. Attach the Trigger to the Predictions table
DROP TRIGGER IF EXISTS on_prediction_change_stats ON public.predictions;
CREATE TRIGGER on_prediction_change_stats
AFTER INSERT OR UPDATE OR DELETE ON public.predictions
FOR EACH ROW EXECUTE FUNCTION update_guru_stats();

-- C. Convert credibility_score to a Generated Column
-- First, drop the old manual column
ALTER TABLE public.gurus DROP COLUMN IF EXISTS credibility_score;

-- Add the new auto-calculating column
ALTER TABLE public.gurus 
ADD COLUMN credibility_score numeric(5,2) 
GENERATED ALWAYS AS (
  CASE 
    WHEN total_predictions = 0 THEN 0 
    ELSE (correct_prediction_count::numeric / total_predictions) * 100 
  END
) STORED;