-- ==============================================================================
-- 1. CLEANUP (If you are starting completely fresh, this drops old structures)
-- WARNING: This drops existing user_roles. Remove these drops if you want to migrate data manually.
-- ==============================================================================
DROP TABLE IF EXISTS public.role_permissions CASCADE;
DROP TABLE IF EXISTS public.user_roles CASCADE;
DROP TYPE IF EXISTS public.app_permission CASCADE;
DROP TYPE IF EXISTS public.app_role CASCADE;

-- ==============================================================================
-- 2. ENUMS: The Source of Truth for Valid Roles and Permissions
-- Using ENUMs prevents typos and strictly enforces what permissions exist.
-- ==============================================================================
CREATE TYPE public.app_role AS ENUM ('admin', 'moderator', 'user');

CREATE TYPE public.app_permission AS ENUM (
  -- Gurus
  'gurus.create',
  'gurus.update.own',
  'gurus.update.any',
  'gurus.delete.own',
  'gurus.delete.any',
  
  -- Predictions (The Own vs. Any Paradigm)
  'predictions.create',
  'predictions.update.own',
  'predictions.update.any',
  'predictions.delete.own',
  'predictions.delete.any',
  
  -- Comments (Moderation)
  'comments.delete.any',

  -- Global/Admin
  'categories.manage',
  'users.manage'
);

-- ==============================================================================
-- 3. TABLES: Mapping Users -> Roles -> Permissions
-- ==============================================================================

-- Table: Maps Roles to Permissions
CREATE TABLE public.role_permissions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role public.app_role NOT NULL,
  permission public.app_permission NOT NULL,
  UNIQUE (role, permission)
);

-- Table: Maps Users to Roles
CREATE TABLE public.user_roles (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role public.app_role NOT NULL DEFAULT 'user'::public.app_role,
  UNIQUE (user_id, role)
);

-- ==============================================================================
-- 4. SEED DATA: Define what each role can do
-- ==============================================================================

-- ADMIN: Can do everything
INSERT INTO public.role_permissions (role, permission) VALUES
  ('admin', 'users.manage'),
  ('admin', 'categories.manage'),
  ('admin', 'comments.delete.any'),
  ('admin', 'gurus.create'),
  ('admin', 'gurus.update.any'),
  ('admin', 'gurus.delete.any'),
  ('admin', 'predictions.update.any'),
  ('admin', 'predictions.delete.any');

-- MODERATOR: Can manage content, but not users
INSERT INTO public.role_permissions (role, permission) VALUES
  ('moderator', 'categories.manage'),
  ('moderator', 'comments.delete.any'),
  ('moderator', 'gurus.create'),
  ('moderator', 'gurus.update.any'),
  ('moderator', 'predictions.update.any'),
  ('moderator', 'predictions.delete.any');

-- USER: Standard access (Create predictions, and edit/delete ONLY their own)
INSERT INTO public.role_permissions (role, permission) VALUES
  ('user', 'gurus.create'),
  ('user', 'gurus.update.own'),
  ('user', 'gurus.delete.own'),
  ('user', 'predictions.create'),
  ('user', 'predictions.update.own'),
  ('user', 'predictions.delete.own');


-- ==============================================================================
-- 5. THE MAGIC: Supabase Custom Auth Hook
-- This function intercepts the login process, looks up the user's permissions,
-- and permanently stamps them into the JWT token session.
-- ==============================================================================
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER 
SET search_path = public -- Security best practice
AS $$
DECLARE
    claims jsonb;
    user_permissions jsonb;
    user_roles_json jsonb;
BEGIN
    -- 1. Get the user's roles
    SELECT jsonb_agg(DISTINCT ur.role)
    INTO user_roles_json
    FROM public.user_roles ur
    WHERE ur.user_id = (event->>'user_id')::uuid;

    -- 2. Get the exact permissions for those roles
    SELECT jsonb_agg(DISTINCT rp.permission)
    INTO user_permissions
    FROM public.user_roles ur
    JOIN public.role_permissions rp ON ur.role = rp.role
    WHERE ur.user_id = (event->>'user_id')::uuid;

    -- 3. Prepare the claims object
    claims := event->'claims';

    -- 4. Inject into app_metadata
    IF user_roles_json IS NOT NULL THEN
        claims := jsonb_set(claims, '{app_metadata, roles}', user_roles_json);
    ELSE
        claims := jsonb_set(claims, '{app_metadata, roles}', '["user"]'::jsonb);
    END IF;

    IF user_permissions IS NOT NULL THEN
        claims := jsonb_set(claims, '{app_metadata, permissions}', user_permissions);
    ELSE
        -- Default to basic user permissions if they have no row in user_roles
        claims := jsonb_set(claims, '{app_metadata, permissions}', '["predictions.create", "predictions.update.own", "predictions.delete.own"]'::jsonb);
    END IF;

    -- 5. Return the modified event back to Supabase Auth
    event := jsonb_set(event, '{claims}', claims);
    RETURN event;
END;
$$;

-- Secure the hook so ONLY Supabase Auth can run it
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM public, authenticated, anon;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;


-- ==============================================================================
-- 6. BASIC SECURITY: Lock down the new tables
-- ==============================================================================
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- Users can read their own roles (helpful for UI if needed, though it's in the JWT now)
CREATE POLICY "Users can read own roles" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);
-- Only Admins can modify roles
CREATE POLICY "Admins can manage roles" ON public.user_roles FOR ALL USING ((auth.jwt() -> 'app_metadata' -> 'permissions') ? 'users.manage');

-- Role permissions are readable by everyone, editable by none (except service_role/superadmin)
CREATE POLICY "Public read role_permissions" ON public.role_permissions FOR SELECT USING (true);